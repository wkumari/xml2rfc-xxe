/*
 * css to allow WYSIKLWYG editing of xml2rfc format
 * using XMLmind XML editor.
 *
 * $Id$
 */

* {
	display: block;
}

/*
 * Need to write a gadget to handle processing-instructions inside the
 * <rfc> (I've seen needLines, subcompact, and of course include)
*:processing-instruction(rfc) {
	content: "<?rfc " gadget("com.att.research.fenner.xmleditapp.xml2rfc.RFCPI") "?>";
}
 */

/* Headings for major sections of the document. */
rfc:before,
rfc > front:before,
rfc > middle:before,
rfc > back:before {
	display: block;
	font-size: 120%;
	font-weight: bold;
	text-align: center;
	background-color: #ff9900;
}
rfc,
rfc > front,
rfc > middle,
rfc > back {
	border: 2 solid #ff9900;
	margin: 0 0 2 0;
}
rfc::attribute() {
	attribute-content-left: "[" attribute-label() ":";
	attribute-content-middle: value-editor(attribute, attribute());
	attribute-content-right: "] ";
	font-size: 80%;
}
rfc::attribute(category),
rfc::attribute(ipr) {
	show-attribute: always;
}
rfc:before {
	/* to do:
	     write java function to handle node-set of processing
	     instructions, return something that renders better here (table?).
	     Unfortunately, xxe is designed to edit documents starting
             at the root node, so we can't edit these processing
             instructions. */
	content: xpath("if(/processing-instruction('rfc'), concat('[Processing instructions: ', join(/processing-instruction('rfc'), ', '), ']\A'), '')") "RFC metadata: " attributes();
}
rfc > front:before {
	content: "RFC Front Matter";
}
rfc > middle:before {
	content: "RFC Middle Matter";
}
rfc > back:before {
	content: "RFC Back Matter";
}
rfc > front title {
	font-size: 150%;
	text-align: center;
}

/* Front abstract */
rfc > front abstract:before {
	display: block;
	content: "Abstract";
	font-size: 120%;
	font-weight: bold;
	text-align: center;
}
abstract,note {
	margin: 0.6em 2em;
}

note:before {
	display: block;
	content: "Note: " text-field(attribute, title);
	font-size: 120%;
	font-weight: bold;
	text-align: center;
}

/* Author and address formatting */
address:before {
	content: "Address: ";
	text-indent: -1em;
}
address {
	margin-left: 1em;
}
/*
 * Display tags in the margin of the postal address
 */
address postal * {
	margin-left: 4em;
}
address postal *:before {
	display: marker;
	content: element-label();
	font-size: 80%;
}
address *:before {
	content: element-label() ": ";
}
address postal:before {
	content: "";
}
/* Collapse author details by default */
author {
	collapsible: yes;
	collapsed: yes;
	not-collapsible-head: 1;
}
author::attribute(role) {
	attribute-content-left: "[role:";
	attribute-content-middle: value-editor(attribute, attribute());
	attribute-content-right: "] ";
}
/* Should these be inline attributes too? */
author:before {
	content: collapser() "Author: " attr(fullname) " (" attr(initials) " " attr(surname) ")" attributes();
}
organization:before {
	content: "Organization: ";
}
organization[abbrev]:after {
	content: " (aka " attr(abbrev) ")";
}
area:before {
	content: "Area: ";
}
workgroup:before {
	content: "Working Group: ";
}
keyword:before {
	content: "Keyword: ";
}
date:before {
	content: "Date: ";
}
date {
	content: attr(day) " " attr(month) " " attr(year);
}
/*
 * Make all anchors editable if present.
 * Display "[not referenced]" if it's not the target of an xref.
 * Display "[DUPLICATE ANCHOR]" if it's a duplicate of another anchor.
 * Make it all red if it's a reference element that's not referenced, or
 *  if it's a duplicate.
 */
*::attribute(anchor) {
	attribute-content-left: "[a:";
	attribute-content-middle: text-field(attribute, anchor, columns, 10);
	attribute-content-right: xpath('if(//xref[@target=current()/@anchor], "", "[not referenced] ")') xpath('if(count(//*[@anchor=current()/@anchor]) = 1, "", "[DUPLICATE ANCHOR] ")') "] ";
	show-attribute: when-added;
	color: concatenate(xpath('if((local-name(.)!="reference" or //xref[@target=current()/@anchor]) and (count(//*[@anchor=current()/@anchor]) = 1),"purple","red")'));
	font-size: 80%;
}
section {
	collapsible: yes;
	not-collapsible-head: 1;
	margin: 0.33em 1em;
}
section::attribute(toc) {
	attribute-content-left: "[toc:";
	attribute-content-middle: value-editor(attribute, attribute());
	attribute-content-right: "] ";
	color: #ff9900;
	font-size: 80%;
}
/* Handle 5-level-embedded sections; anything beyond 5 will be marked
 * as failing.  Too bad "counters" doesn't work. */
section:before {
	content: collapser() attributes() "Section " counter(n) ". " text-field(attribute, title);
	font-size: 150%;
	text-indent: -1em;	/* this doesn't outdent like it does Address: */
}
section section:before {
	content: collapser() attributes() "Section " counter(nn) ". " text-field(attribute, title);
	font-size: 125%;
}
section section section:before {
	content: collapser() attributes() "Section " counter(nnn) ". " text-field(attribute, title);
}
section section section section:before {
	content: collapser() attributes() "Section " counter(nnnn) ". " text-field(attribute, title);
}
section section section section section:before {
	content: collapser() attributes() "Section " counter(nnnnn) ". " text-field(attribute, title);
}
section section section section section section:before {
	content: collapser() attributes() "Section (auto-numbering failed)." counter(nnnnn) ". " text-field(attribute, title);
}
back section:before {
	content: collapser() attributes() "Appendix " counter(n, upper-alpha) ". " text-field(attribute, title);
}
back section section:before {
	content: collapser() attributes() "Appendix " counter(n-, upper-alpha) "." counter(n) ". " text-field(attribute, title);
}
back section section section:before {
	content: collapser() attributes() "Appendix " counter(n--, upper-alpha) "." counter(nn) ". " text-field(attribute, title);
}
back section section section section:before {
	content: collapser() attributes() "Appendix " counter(n---, upper-alpha) "." counter(nnn) ". " text-field(attribute, title);
}
back section section section section section:before {
	content: collapser() attributes() "Appendix (auto-numbering failed)." counter(nnnn) ". " text-field(attribute, title);
}
t {
	margin-bottom: 1em;
}
title:after {
	content: label(xpath,"if(string-length(.) > 39, ' <-- should have abbrev', '')");
	color: red;
}
title[abbrev]:after {
	content: " (aka " text-field(attribute, abbrev) ")";
	color: inherit;
}
xref, eref {
	display: inline;
	color: green;
}
xref::attribute(target),
eref::attribute(target) {
	attribute-content-left: " [" element-label() " to:";
	attribute-content-middle: value-editor(attribute, attribute());
	attribute-content-right: "]";
	show-attribute: always;
	color: purple;
	font-size: 80%;
}
/*
 * xpath stuff for xrefs:
 * - Find the node whose anchor is our target.
 * - If there's a title (a section or an appendix or ...?), render it.
 * - If there's a front/title (a reference), render that.
 * - If the node exists, render "ok".
 * - If there's an <?rfc include=?> with this target, render "included"
 *   - 2 parts: if the target begins with RFC, check for reference.RFC.n
 *   - else, check for reference.@target
 * - Else, render "(not found)".
 */
xref:after {
	display: inline;
	content: attributes() " [" xpath("if(//*[@anchor=current()/@target]/@title, //*[@anchor=current()/@target]/@title, if(//*[@anchor=current()/@target]/front/title, //*[@anchor=current()/@target]/front/title, if(//*[@anchor=current()/@target], 'ok', if(//processing-instruction('rfc')[starts-with(normalize-space(.),'include=') and substring(normalize-space(.), 10, 10)='reference.' and ((starts-with(current()/@target, 'RFC') and substring-after(substring(normalize-space(.), 20, string-length(normalize-space(.))-20), 'RFC.')=substring-after(current()/@target, 'RFC')) or (starts-with(current()/@target, 'RFC')=false and substring(normalize-space(.), 20, string-length(normalize-space(.))-20)=current()/@target))], 'included', '(not found)'))))") "]";
	color: purple;
}
eref:after {
	display: inline;
	content: attributes();
	color: purple;
}
iref::attribute() {
	show-attribute: when-added;
	color: purple;
	font-size: 80%;
}
iref::attribute(subitem) {
	attribute-content-left: "[" attribute-label() ":";
	attribute-content-middle: value-editor(attribute, attribute());
	attribute-content-right: "] ";
}
iref::attribute(primary) {
	attribute-content-left: "[";
	attribute-content-middle: check-box(attribute, primary,
					    label, attribute-label(),
					    checked-value, "true",
					    unchecked-value, "false");
	attribute-content-right: "] ";
}
iref {
	/* need to reduce the margins for a series of irefs */
	display: block;
	content: " [Index: " text-field(attribute, "item") attributes() "] ";
	color: purple;
}
/*
 * I'd like cref to be collapsible, but elements without sub-elements
 * can't be.
 */
cref::attribute() {
	attribute-content-left: "[" attribute-label() ":";
	attribute-content-middle: value-editor(attribute, attribute());
	attribute-content-right: "]";
	color: purple;
	font-size: 80%;
}
cref:before {
	content: "[[ comment" attributes() ": ";
}
cref {
	background-color: yellow;
}
cref:after {
	content: " ]]";
}
vspace {
	display: block;
	/* These command-buttons are for increment and decrement operations. */
	content: "--- vspace(" text-field(attribute, "blankLines", columns, 2) ") " command-button(icon, icon(plus-box), command, "putAttribute", parameter, xpath("concat('blankLines ', ./@blankLines + 1)")) command-button(icon, icon(minus-box), command, "putAttribute", parameter, xpath("concat('blankLines ', ./@blankLines - 1)")) " ---";
	color: purple;
	font-size: 80%;
	/* Whitespace at the bottom of the element */
	padding-bottom: concatenate(xpath("if(@blankLines > 1, @blankLines - 1, 0)"), "em");
}
spanx {
	display: inline;
	font-style: italic;
}
spanx[style=emph] {
	display: inline;
	font-style: italic;
}
spanx[style=strong] {
	display: inline;
	font-weight: bold;
	font-style: normal;
}
spanx[style=verb] {
	display: inline;
	font-family: monospace;
	font-style: normal;
}
list::attribute(counter) {
	attribute-content-left: " [(not supported) counter:";
	color: red;
}
list::attribute(style) {
	show-attribute: never;
}
list::attribute() {
	attribute-content-left: " [" attribute-label() ":";
	attribute-content-middle: value-editor(attribute, attribute());
	attribute-content-right: "] ";
	show-attribute: when-added;
}
/* A handle for the list */
/* todo: offer an easy way to convert[wrap] <t> if needed? */
list:before {
	content: icon(right) "[list style " attr(style) attributes() xpath('if(local-name(..) = "t", "", " NOTE: list must be inside <t>")') "]";
	font-size: 80%;
	color: concatenate(xpath('if(local-name(..) = "t","#ff9900","red")'));
}
list t {
	margin: 0.33em 2em;
}
/* Catch-all for formats that we don't handle. */
list[style] > t:before {
	display: marker;
	content: "???";
}
/* 3 levels of symbols */
list[style=symbols] > t:before {
	display: marker;
	content: disc;
}
list[style=symbols] list[style=symbols] > t:before {
	content: square;
}
list[style=symbols] list[style=symbols] list[style=symbols] > t:before {
	content: icon(diamond);
}
/* hanging lists */
list[style=hanging][hangIndent] > t {
	margin-left: concatenate(xpath("../@hangIndent"), "em");
}
list[style=hanging] > t {
	margin-left: 6em;
}
list[style=hanging] > t:before {
	display: marker;
	content: text-field(attribute, "hangText", columns, xpath("if(../@hangIndent,../@hangIndent, 6)")) " ";
}
list[style=numbers] > t:before {
	display: marker;
	content: counter(n) ".";
}
list[style=letters] > t:before {
	display: marker;
	content: counter(n, lower-alpha) ".";
}
/* to do: java to support style=format */
list[style^=format] > t {
	/* to do: find better unit for this */
	margin-left: concatenate(xpath("(string-length(../@style)-5)*0.6"), "em");
}
list[style^=format] > t:before {
	display: marker;
	content: "?" xpath('substring-after(../@style, "format ")') "?";
	color: red;
}
list[style=empty] > t:before {
	content: "";	/* override the catch-all */
}

/* A handle for a figure.  Also warn about document model change
 * deprecating <t><figure>.
 */
figure:before {
	content: collapser() "[figure" attributes() xpath('if(local-name(..) = "t"," NOTE: figure inside <t> is deprecated in 2629bis","")') "]";
	color: concatenate(xpath('if(local-name(..) = "t","red","#ff9900")'));
}
figure::attribute(title) {
	attribute-content-left: "[" attribute-label() ":";
	attribute-content-middle: value-editor(attribute, attribute());
	attribute-content-right: "] ";
	color: black;
}
figure {
	collapsible: yes;
	collapsed: no;
	not-collapsible-head: 1;
}
/* Attributes on artwork are ugly, but rare, so fine tuning can wait. */
artwork::attribute() {
	attribute-content-left: "[" attribute-label() ":";
	attribute-content-middle: value-editor(attribute, attribute());
	attribute-content-right: "] ";
	color: purple;
	show-attribute: when-added;
}
figure artwork:before {
	display: block;
	content: attributes();
	white-space: normal;
	font-family: sans-serif;
	background-color: white;
}
figure artwork {
	display: block;
	white-space: pre;
	font-family: monospace;
	background-color: #ffffcc;
	/* can we display a vertical line at 70 characters? */
}

back > references:before {
	display: block;
	content: xpath("if(@title, @title, 'References')");
	font-size: 125%;
}
references > reference:before {
	content: collapser() "Reference " attributes();
}
/* Don't display abstracts in references */
reference abstract {
	display: none;
}
reference seriesInfo {
	content: "Series: " attr(name) " Doc: " attr(value);
}
reference format {
	content: "Format " attr(type);
}
reference title:before {
	content: "Title: ";
}
reference annotation:before {
	content: "Annotation: ";
}
reference {
	display: block;
	collapsible: yes;
	collapsed: yes;
	not-collapsible-head: 1;
}
/*
 * texttable problems:
 * preamble and postamble need to be outside "display: table"
 * <ttcol> and <c> need to be virtually inside table-rows
 * <ttcol> contains the alignment for all of the <c>s
 */
texttable:before {
	content: "texttable not supported";
	color: red;
}
texttable {
	display: table;
	border: 1 solid black;
	padding: 2;
	border-spacing: 2;
	background-color: silver;
}
/*
 * Can't use table-caption for the postamble, since it displays
 * before the table.  Give them each their own row, and make them
 * look the same; they will still appear as a row inside the table.
 * Don't know yet how this will appear when the actual table stuff
 * is working.
 */
texttable > preamble,
texttable > postamble {
	display: block;
	color: #004080;
	background-color: white;
}
texttable > ttcol {
	display: table-cell;
	font-weight: bold;
	color: olive;
}
texttable > c {
	display: table-cell;
}
/*
 to do:
 texttable
  (can we do the "every count(ttcol) c's is a row" thing?)
  (probably needs java help)
 <?rfc include= -- editable attribute
 list: can we inherit style from the closest parent as specified?
 additional validation: can we enforce things like the structure
  of the postal?
 Do any of the xpath() rendering bits need to be label()s?
*/
